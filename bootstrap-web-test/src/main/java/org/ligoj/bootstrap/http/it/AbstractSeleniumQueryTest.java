package org.ligoj.bootstrap.http.it;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.TimeUnit;

import org.openqa.selenium.By;
import org.openqa.selenium.NoSuchElementException;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.ui.Select;
import org.openqa.selenium.support.ui.WebDriverWait;

/**
 * Common Selenium test class, provides convenient methods to interact with browsers.
 */
public abstract class AbstractSeleniumQueryTest extends AbstractSeleniumLauncherTest {

	protected static final String S2_ID = "//div[@id='s2id_";

	protected static final String DATATABLES_ID = "//table[@id='";

	/**
	 * Find the bootstrap control group of an element in a form. Usefull to check validation error
	 * 
	 * @param elementId
	 *            Id of the element
	 * @return Element location
	 */
	protected By findControlGroup(final String elementId) {
		return By.xpath("//div[contains(@class,'control-group')]//*[@id='" + elementId + "']/../..");
	}

	/**
	 * Find the first child of a cell (useful for editing grid, because each cell contains select or input)
	 * 
	 * @param tableId
	 *            Id of the datatable
	 * @param row
	 *            Row number (First row : 1)
	 * @param column
	 *            Column number (first column : 1)
	 * @return Element location
	 */
	protected By findCellChild(final String tableId, final int row, final int column) {
		return By.xpath(DATATABLES_ID + tableId + tableXPath(row, column) + "/*[1]");
	}

	/**
	 * Find a cell (useful for read only table or to have error associated to a cell in editing grid)
	 * 
	 * @param tableId
	 *            Id of the datatable
	 * @param row
	 *            Row number (First row : 1)
	 * @param column
	 *            Column number (first column : 1)
	 * @return Element location
	 */
	protected By findCell(final String tableId, final int row, final int column) {
		return By.xpath(DATATABLES_ID + tableId + tableXPath(row, column));
	}

	/**
	 * Find error text on the specified cell
	 * 
	 * @param tableId
	 *            Id of the table
	 * @param row
	 *            Row index (first : 1)
	 * @param column
	 *            Column index (first : 1)
	 * @return Error text
	 */
	protected String findErrorInTable(final String tableId, final int row, final int column) {
		return driver.findElement(By.xpath(DATATABLES_ID + tableId + tableXPath(row, column))).getAttribute("title");
	}

	protected String tableXPath(final int row, final int column) {
		return "']/tbody/tr[" + row + "]/td[" + column + "]";
	}

	/**
	 * Assert that the given select has the expected selected text
	 * 
	 * @param by
	 *            Select location
	 * @param expectedText
	 *            Expected selected text
	 */
	protected void assertSelectedText(final String expectedText, final By by) {
		new WebDriverWait(driver, timeout).until(d -> new Select(driver.findElement(by)).getFirstSelectedOption().getText().equals(expectedText));
	}

	/**
	 * Wait for the given element to be available and return it
	 * 
	 * @param by
	 *            Element location
	 * @return Element
	 */
	protected WebElement getElement(final By by) {
		return new WebDriverWait(driver, timeout)
				.until(d -> Optional.ofNullable(driver.findElement(by)).filter(WebElement::isDisplayed).orElse(null));
	}

	/**
	 * Remove an option in a select2 component
	 * 
	 * @param select2Id
	 *            Id of the select2 (id put in the HTML file, not the one generated by select2)
	 * @param option2Remove
	 *            Text of the option to remove
	 */
	protected void select2RemoveValue(final String select2Id, final String option2Remove) throws InterruptedException {
		getElement(By.xpath(S2_ID + select2Id + "']//div[text()='" + option2Remove + "']/../a")).click();
		smallSleep();
	}

	/**
	 * Select an option in a select2 component
	 * 
	 * @param select2Id
	 *            Id of the select2 (id put in the HTML file, not the one generated by select2)
	 * @param option2Add
	 *            Text of the option to select
	 */
	protected void select2SelectValue(final String select2Id, final String option2Add) throws InterruptedException {
		// Click on the select 2 to display the options
		// * = ul for a multiselect, a for a single select
		getElement(By.xpath(S2_ID + select2Id + "']/*")).click();

		// Click on the option
		getElement(By.xpath("//div[@class='select2-result-label' and text()='" + option2Add + "']")).click();

		smallSleep();
	}

	/**
	 * Select an option in a select2 component
	 * 
	 * @param select2Id
	 *            Id of the select2 (id put in the HTML file, not the one generated by select2)
	 * @param optionNumber
	 *            Number of the option to select (1 = first one, ...)
	 */
	protected void select2SelectValue(final String select2Id, final int optionNumber) throws InterruptedException {
		// Click on the select 2 to display the options
		// * = ul for a multiselect, a for a single select
		getElement(By.xpath(S2_ID + select2Id + "']/*")).click();

		// Click on the option
		getElement(By.xpath("(//div[@class='select2-result-label'])[" + optionNumber + "]")).click();

		smallSleep();
	}

	/**
	 * Get the current values selected in a select2 multi-value component
	 * 
	 * @param select2Id
	 *            Id of the select2
	 * @return List of the values
	 */
	protected List<String> select2GetValues(final String select2Id) {
		final List<String> options = new ArrayList<>();
		int numOption = 0;
		while (true) { // NOSONAR - Increment the select index until there is no more entries
			numOption++;
			try {
				options.add(driver.findElement(By.xpath(S2_ID + select2Id + "']/ul/li[" + numOption + "]/div")).getText());
			} catch (final NoSuchElementException ex) { // NOSONAR - No more element
				break;
			}
		}

		return options;
	}

	/**
	 * Select the option based on the option's text
	 * 
	 * @param by
	 *            Select location
	 * @param optionText
	 *            Text of the option to select
	 */
	protected void selectOptionByText(final By by, final String optionText) {
		new Select(getElement(by)).selectByVisibleText(optionText);
	}

	/**
	 * Wait for the server to answer : only use this when no screen modification is detectable. Very long (10 s)
	 */
	protected void waitFixedTime() {
		driver.manage().timeouts().implicitlyWait(1, TimeUnit.SECONDS);
	}
}
